[{"content":"Java笔记 集合框架 Collection集合体系特点 List(接口)：添加元素有序、可重复、有索引 ArrayList(实现类)： 基于数组实现 查询快，删除/添加慢（需移动元素） LinkedList(实现类)： 基于双链表实现 查询慢，增删快，首尾操作极快 新增了许多首尾操作方法 Set(接口)：无序、不可重复、无索引 HashSet(实现类)： 无序、不可重复、无索引 JDK8前：数组+链表，JDK8后：数组+链表+红黑树 可重写hashCode和equals保证自定义对象去重 LinkedHashSet(实现类)： 有序、不可重复、无索引 底层数组+链表+红黑树+双链表机制 占用内存大，CRUD性能好 TreeSet(实现类)： 默认升序排序、不可重复、无索引 底层红黑树 自定义类型需实现Comparable或传Comparator 遍历集合 迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //1.从集合对象中获取迭代器对象 Collection\u0026lt;String\u0026gt;C=newArrayList\u0026lt;\u0026gt;(); c.add(\u0026#34;赵敏\u0026#34;); c.add(\u0026#34;小昭\u0026#34;); c.add(\u0026#34;素素\u0026#34;); c.add(\u0026#34;灭绝\u0026#34;); //手动遍历 Iterator\u0026lt;String\u0026gt; it = c.iterator(); System.out.println(it.next()); System.out.println(it.next()); System.out.println(it.next()); System.out.println(it.next()); //循环结合迭代器 while(it.hashNext()){ String ele = it.next(); System.out.println(ele); } 增强for循环 1 2 3 for(String ele : c){ System.out.println(ele); } Lambda表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //原始代码 c.forEach(new Consumer\u0026lt;String\u0026gt;()){ @Override public void accept(String s){ System.out.println(s); } } //可简化为↓ c.forEach((String s){ System.out.println(s); }); //只有一个参数小括号类型可省略且循环体只有一条语句大括号可省略↓ c.forEach(s -\u0026gt; System.out.println(s)); //最终可省略为↓ c.forEach(System.out::println); 集合并发修改异常 使用迭代器遍历集合同时删除元素会抛出异常 解决方法： 用迭代器自己的remove方法删除 for循环倒序遍历删除，或正序遍历时删除后i\u0026ndash; Map集合体系 Map(接口) HashMap(实现类)： 无序、不重复、无索引 JDK8前：数组+链表，JDK8后：数组+链表+红黑树 可重写hashCode和equals保证自定义对象去重 LinkedHashMap(实现类)： 有序、不可重复、无索引 底层数组+链表+红黑树+双链表机制 占用内存大，CRUD性能好 TreeMap(实现类)： 默认升序排序、不可重复、无索引 底层红黑树 自定义类型需实现Comparable或传Comparator 遍历Map集合 键找值： 用keySet获取所有键，遍历Set用get方法取值 键值对： 用entrySet获取Set\u0026lt;Map.Entry\u0026lt;K,V\u0026raquo;，遍历Entry用getKey/getValue Lambda表达式： 1 map.forEach((k, v) -\u0026gt; System.out.println(k + \u0026#34;:\u0026#34; + v)); Stream流 JDK8新增API(java.util.stream.*)用于操作集合或数组 优势：结合Lambda，代码简洁、可读性好 常用操作 ​中间操作​​： filter(Predicate)：过滤 map(Function)：映射转换 distinct()：去重 sorted()：排序 limit(long)：限制数量 skip(long)：跳过元素 终端操作​​： forEach(Consumer)：遍历 count()：计数 collect(Collector)：收集 reduce()：归约 anyMatch()/allMatch()/noneMatch()：匹配检查 findFirst()/findAny()：查找 static静态修饰符 可修饰变量、方法、内部类 静态变量/方法可通过类名访问，变量存储在静态区 静态方法不能直接访问非静态变量 静态内部类可直接实例化 锁 Java锁分为两类： Synchronized同步锁 ​​锁升级过程​​： 无锁 -\u0026gt; 偏向锁 -\u0026gt; 轻量级锁 -\u0026gt; 重量级锁 JDK6后引入锁消除、锁粗化等优化 使用方式​​： 同步代码块：synchronized(obj) {\u0026hellip;} 同步方法：public synchronized void method() {\u0026hellip;} 静态同步方法：锁的是类对象 JUC包下各种锁（如ReentrantLock可重入锁） ReentrantLock 特点： 可重入 可中断 公平/非公平可选 可设置超时 ReentrantLock基本用法 1 2 3 4 5 6 7 Lock lock = new ReentrantLock(); lock.lock(); try { // 临界区代码 } finally { lock.unlock(); } 特性 Synchronized ReentrantLock 实现方式 JVM层面 JDK层面 锁获取 自动 手动 可中断 不支持 支持 公平锁 非公平 可配置 条件队列 单一 多个Condition 性能 JDK6后优化良好 高竞争时更优 ThreadLocal 线程局部变量，为每个线程提供独立副本 解决多线程共享变量的数据竞争，无需加锁 可用于方法调用链中传递上下文信息 局部变量仅用于单方法，ThreadLocal可在单线程多方法间共享 局部变量线程安全（栈帧独立），但引用共享对象时需注意 内存泄漏问题： ThreadLocal对象为弱引用，value为强引用，若Thread未终止，Entry会一直存在 示例： 1 2 3 ThreadLocal\u0026lt;String\u0026gt; tl = new ThreadLocal\u0026lt;\u0026gt;(); tl.set(\u0026#34;value\u0026#34;); tl = null; // ThreadLocal对象失去强引用，Entry.key=null但value还在 CAS 什么是CAS？\nCAS(Compare-And-Swap)是一种无锁的原子操作机制，它包含三个操作数：内存位置(V)、预期原值(A)和新值(B)。当且仅当V的值等于A时，CAS才会将V的值更新为B，否则不做任何操作。\nCAS原理\n​​比较并交换​​：比较当前内存值与预期值，如果相同则更新为新值 ​​原子性​​：整个操作是一个不可分割的原子操作 ​​乐观锁​​：假设没有冲突，失败则重试\n常用原子类\nAtomicInteger/AtomicLong：整型原子类 AtomicBoolean：布尔型原子类 AtomicReference：引用类型原子类 AtomicIntegerArray/AtomicLongArray：数组原子类\nCAS优缺点\n优点: 非阻塞，线程无需挂起 避免锁带来的上下文切换开销 适合低竞争场景，性能高 缺点: ABA问题​​：值从A变B又变回A，CAS会认为没变化 解决方案：使用版本号（AtomicStampedReference）循环时间长开销大​​竞争激烈时可能长时间自旋 只能保证一个变量的原子性，​​多个变量需额外处理 CAS应用场景\n计数器（如AtomicInteger） 乐观锁实现 无锁数据结构（如ConcurrentHashMap的部分实现） ","date":"2025-03-11T00:00:00Z","image":"https://Pupil770.github.io/p/java%E7%AC%94%E8%AE%B0/bg2_hu_86c750a017f32df0.png","permalink":"https://Pupil770.github.io/p/java%E7%AC%94%E8%AE%B0/","title":"Java笔记"}]